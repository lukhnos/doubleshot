<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="DoubleShot : A CoffeeScript Dialect with Cross-Platform Concurrency Primitives" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>DoubleShot</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/lukhnos/doubleshot">View on GitHub</a>

          <h1 id="project_title">DoubleShot</h1>
          <h2 id="project_tagline">A CoffeeScript Dialect with Cross-Platform Concurrency Primitives</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/lukhnos/doubleshot/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/lukhnos/doubleshot/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>DoubleShot: A CoffeeScript Dialect with Cross-Platform Concurrency Primitives</h1>

<p>DoubleShot is a CoffeeScript dialect that adds two concurrency primitives to
the language: <code>submodule</code> and <code>asyncrun</code>. A submodule defines an
independently-scoped program, which can be then spawned from the main program
as workers. The main program and the workers communicate with a message
passing mechanism.</p>

<p>Currently DoubleShot programs can be compiled to two "platforms": the web
browser, using HTML5 workers; and node.js, using the <code>cluster</code> library. The
concurrency model is the same as the HTML5 worker: share-nothing actors with
heavy setup and teardown costs. It is possible to extend the DoubleShot
compiler to generate JavaScript code using other concurrency libraries.</p>

<h2>Motivations</h2>

<p>The motivation of DoubleShot is to provide a set of cross-platform concurrency
primitives for CoffeeScript. The current HTML5 worker and node.js cluster
library have their respective issues. The HTML5 standard requires workers to
be loaded from separate URLs, meaning they have to be written as separate
programs. There are non-standard ways to load the workers within the same
program, but that is not supported in every modern browser and involves DOM
manipulation. node.js cluster uses fork to implement the workers and requires
delicate setup to separate the master and worker code.</p>

<p>Since CoffeeScript already provides a level of abstraction from JavaScript, we
can build upon its compiler infrastructure to do the code generation and
rewriting for our concurrent programs. When DoubleShot targets HTML5 worker,
it generates separate JavaScript programs for respective submodules. When it
targets node.js cluster, it performs code motion to provide proper setup for
the master and workers. It also provides a unified message-passing API.
Concurrent programs written in DoubleShot can therefore be easily reused
across the different client- and server-side platforms by simply recompiling.</p>

<h2>Compiling DoubleShot Programs</h2>

<p>DoubleShot adds two additional options to CoffeeScript's <code>coffee</code> frontend:</p>

<ul>
<li>  <code>-N</code> generates JavaScript code that runs on node.js</li>
<li>  <code>-W</code> generates JavaScript code, along with separate worker files, for
HTML5 worker</li>
</ul><h2>Example</h2>

<p>The <code>basicworker</code> sample app demonstrates how a simple master-worker program
can be run on both node.js and web browser.</p>

<p>To run on web browser:</p>

<pre><code>coffee -Wc main.coffee
</code></pre>

<p>Then copy <code>index.html</code> and the generated <code>.js</code> files to a folder to which you
have web server access. For security reasons most web browsers forbids loading
web workers from <code>file://</code> URLs. I've put up some examples:</p>

<ul>
<li><p>A simple program in which the worker echoes back the master's message:
<a href="http://lukhnos.org/doubleshot/examples/basicworker/">http://lukhnos.org/doubleshot/examples/basicworker/</a></p></li>
<li><p>Using web workers to do matrix multiplication
<a href="http://lukhnos.org/doubleshot/examples/matrixmul/">http://lukhnos.org/doubleshot/examples/matrixmul/</a></p></li>
</ul><p>Those examples can also run on node.js. See the <code>examples/</code> for details.</p>

<p>To run on node.js:</p>

<pre><code>coffee -Nc main.coffee
node main.js
</code></pre>

<p>Note that because of the way CoffeeScript and node.js cluster work (in short,
the forked process does not start at the point it was forked), it is
impossible to run the programs directly within <code>coffee</code>. That's why we need to
compile it to JavaScript first then run it with <code>node</code>.</p>

<p>In addition, these two sample that only run on node.js. It demonstrates how
you can use DoubleShot for server-side programming:</p>

<ul>
<li><p>A rewritten version of node.js cluster server example using DoubleShot:
<a href="https://github.com/lukhnos/doubleshot/tree/master/examples/doubleshot/clusterserver">https://github.com/lukhnos/doubleshot/tree/master/examples/doubleshot/clusterserver</a></p></li>
<li><p>A contrived non-blocking server example:
<a href="https://github.com/lukhnos/doubleshot/tree/master/examples/doubleshot/nonblockingserver">https://github.com/lukhnos/doubleshot/tree/master/examples/doubleshot/nonblockingserver</a>    </p></li>
</ul><h2>Basic Syntax</h2>

<p>It is easy to define a submodule:</p>

<pre><code>foo = submodule 'foo-worker.js'   # the name is optional
    # define the submoudle here
</code></pre>

<p>The name in the example <code>'foo-worker.js'</code> is optional. It's really only used
when targeting HTML5 worker, and it tells the DoubleShot compiler to generate
the worker's JavaScript file under that name. If no name is given, a uniquely
numbered file name is assigned to each submodule.</p>

<p>Once you have defined a submodule, you can spawn a worker off it:</p>

<pre><code>worker = asyncrun foo
# setup the communication
worker.send 'a message'  # a string message
worker.send cmd:'run', iteration:10  # an object message
</code></pre>

<h2>Setup the Communication between the Master and the Workers</h2>

<p>In DoubleShot, the master and the spawned workers communicate with a
message-passing mechanism. The master <em>sends</em> messages to the workers, and
they <em>reply</em> to the messages. To setup how the master handles the response, do
this:</p>

<pre><code>worker = asyncrun foo
worker.receive = (msg) -&gt;
    # handle the receive here
</code></pre>

<p>In the submodule, the setup is similiar. Note that in a submodule, we use the
keyword <code>moduleSelf</code> to refer to the current program:</p>

<pre><code>foo = submodule
    moduleSelf.receive = (msg) -&gt;
        # do some computations
        someReply = ...
        moduleSelf.reply someReply
</code></pre>

<h2>Submodules Can Spawn Themselves and Other Submodules (Limited Support)</h2>

<p>Submodules can spawn themselves:</p>

<pre><code>foo = submodule
    moduleSelf.receive = (msg) -&gt;
        # some work requires sub-workers
        subworker = asyncrun moduleSelf
</code></pre>

<p>It can also spawn other submodules:</p>

<pre><code>foo = submodule
    bar = submodule
        # bar code here

    subworker = asyncrun bar
    # setup and send messages
</code></pre>

<p>This corresponds to the HTML5 notion of <em>subworkers</em>. Unfortunately not every
browser supports it. As of writing only Firefox supports subworkers. On the
server-side, node.js cluster forbids forking from worker processes, although
it may be possible to modify the code.</p>

<h2>Termination</h2>

<p>The worker can close itself:</p>

<pre><code>moduleSelf.close()
</code></pre>

<p>(Note that in CoffeeScript you have to add the parentheses to call a method
with no arguments, otherwise you are just referring the method as an object.)</p>

<p>Similarly, the master can force-terminate the worker:</p>

<pre><code>worker.terminate()
</code></pre>

<h2>Error Handling</h2>

<p>If a worker runs into an error, and the error propagates to the master, the
master can specify a handler for such error:</p>

<pre><code>worker = asyncrun foo
worker.error = (err) -&gt;
    # handle the err
</code></pre>

<p>To facilitate debugging, the handler currently only works for HTML5 worker
errors. When targeting node.js, exception raised in the worker is not caught
by a top-level catch, therefore an uncaught exception will die in place.</p>

<h2>Specifying the Worker Load Path for HTML5 Workers</h2>

<p>One design flaw in the current HTML5 worker draft is that workers have to be
loaded with a separate URL, and current browser implementations are messy. For
example, all supporting browsers (Chrome, Safari, Firefox) loads workers from
the relative path of the <em>HTML page</em>, not the <em>master program script</em>. While
Chrome supports relative path in the worker load URL, Firefox doesn't support
it and you have to specify the full URL. This is a problem if your web site
has a layout like this:</p>

<pre><code>/
/index.html
/js
/js/main.js
/js/worker.js
</code></pre>

<p>To circumvent the problem, DoubleShot has a global variable with which you can
specify the worker's load path (suppose the web site is example.com):</p>

<pre><code>&lt;!-- works in Chrome --&gt;
&lt;script&gt;_submoduleLoadPath = "js/";&lt;/script&gt;

&lt;!-- works in Firefox --&gt;
&lt;script&gt;_submoduleLoadPath = "http://example.com/js/";&lt;/script&gt;

&lt;script src="js/main.js"&gt;&lt;/script&gt;
</code></pre>

<p>Admittedly it's not an elegant solution. Better for the browser and standard
makers to fix the problem.</p>

<h2>Notes</h2>

<ul>
<li>  It's called <code>submodule</code> and <code>asyncrun</code> because the the program declared
inside is not really a standalone module, and the terms <code>module</code> and
<code>spawn</code> are already extensively used by node.js. Also <code>asyncrun</code> just
means what the term says: it runs the submodule program asynchronously in
another process or thread (depending on the platform implementation).</li>
</ul><h2>Acknowledgments</h2>

<p>Professor John Mitchell of Stanford University inspired me to investigate the
ways to add concurrency primitives to JavaScript, which led to the present
form of this project.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">DoubleShot maintained by <a href="https://github.com/lukhnos">lukhnos</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
