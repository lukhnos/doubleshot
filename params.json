{"body":"# DoubleShot: A CoffeeScript Dialect with Cross-Platform Concurrency Primitives\r\n\r\nDoubleShot is a CoffeeScript dialect that adds two concurrency primitives to\r\nthe language: `submodule` and `asyncrun`. A submodule defines an\r\nindependently-scoped program, which can be then spawned from the main program\r\nas workers. The main program and the workers communicate with a message\r\npassing mechanism.\r\n\r\nCurrently DoubleShot programs can be compiled to two \"platforms\": the web\r\nbrowser, using HTML5 workers; and node.js, using the `cluster` library. The\r\nconcurrency model is the same as the HTML5 worker: share-nothing actors with\r\nheavy setup and teardown costs. It is possible to extend the DoubleShot\r\ncompiler to generate JavaScript code using other concurrency libraries.\r\n\r\n\r\n## Motivations\r\n\r\nThe motivation of DoubleShot is to provide a set of cross-platform concurrency\r\nprimitives for CoffeeScript. The current HTML5 worker and node.js cluster\r\nlibrary have their respective issues. The HTML5 standard requires workers to\r\nbe loaded from separate URLs, meaning they have to be written as separate\r\nprograms. There are non-standard ways to load the workers within the same\r\nprogram, but that is not supported in every modern browser and involves DOM\r\nmanipulation. node.js cluster uses fork to implement the workers and requires\r\ndelicate setup to separate the master and worker code.\r\n\r\nSince CoffeeScript already provides a level of abstraction from JavaScript, we\r\ncan build upon its compiler infrastructure to do the code generation and\r\nrewriting for our concurrent programs. When DoubleShot targets HTML5 worker,\r\nit generates separate JavaScript programs for respective submodules. When it\r\ntargets node.js cluster, it performs code motion to provide proper setup for\r\nthe master and workers. It also provides a unified message-passing API.\r\nConcurrent programs written in DoubleShot can therefore be easily reused\r\nacross the different client- and server-side platforms by simply recompiling.\r\n\r\n\r\n## Compiling DoubleShot Programs\r\n\r\nDoubleShot adds two additional options to CoffeeScript's `coffee` frontend:\r\n\r\n*   `-N` generates JavaScript code that runs on node.js\r\n*   `-W` generates JavaScript code, along with separate worker files, for\r\n    HTML5 worker\r\n\r\n## Example\r\n\r\nThe `basicworker` sample app demonstrates how a simple master-worker program\r\ncan be run on both node.js and web browser.\r\n\r\nTo run on web browser:\r\n\r\n    coffee -Wc main.coffee\r\n\r\nThen copy `index.html` and the generated `.js` files to a folder to which you\r\nhave web server access. For security reasons most web browsers forbids loading\r\nweb workers from `file://` URLs. I've put up some examples:\r\n\r\n*   A simple program in which the worker echoes back the master's message:\r\n    http://lukhnos.org/doubleshot/examples/basicworker/\r\n    \r\n*   Using web workers to do matrix multiplication\r\n    http://lukhnos.org/doubleshot/examples/matrixmul/\r\n\r\nThose examples can also run on node.js. See the `examples/` for details.\r\n\r\nTo run on node.js:\r\n\r\n    coffee -Nc main.coffee\r\n    node main.js\r\n\r\nNote that because of the way CoffeeScript and node.js cluster work (in short,\r\nthe forked process does not start at the point it was forked), it is\r\nimpossible to run the programs directly within `coffee`. That's why we need to\r\ncompile it to JavaScript first then run it with `node`.\r\n\r\nIn addition, these two sample that only run on node.js. It demonstrates how\r\nyou can use DoubleShot for server-side programming:\r\n\r\n*   A rewritten version of node.js cluster server example using DoubleShot:\r\n    https://github.com/lukhnos/doubleshot/tree/master/examples/doubleshot/clusterserver\r\n    \r\n*   A contrived non-blocking server example:\r\n    https://github.com/lukhnos/doubleshot/tree/master/examples/doubleshot/nonblockingserver    \r\n\r\n\r\n## Basic Syntax\r\n\r\nIt is easy to define a submodule:\r\n\r\n    foo = submodule 'foo-worker.js'   # the name is optional\r\n        # define the submoudle here\r\n\r\nThe name in the example `'foo-worker.js'` is optional. It's really only used\r\nwhen targeting HTML5 worker, and it tells the DoubleShot compiler to generate\r\nthe worker's JavaScript file under that name. If no name is given, a uniquely\r\nnumbered file name is assigned to each submodule.\r\n\r\nOnce you have defined a submodule, you can spawn a worker off it:\r\n\r\n    worker = asyncrun foo\r\n    # setup the communication\r\n    worker.send 'a message'  # a string message\r\n    worker.send cmd:'run', iteration:10  # an object message\r\n\r\n\r\n## Setup the Communication between the Master and the Workers\r\n\r\nIn DoubleShot, the master and the spawned workers communicate with a\r\nmessage-passing mechanism. The master *sends* messages to the workers, and\r\nthey *reply* to the messages. To setup how the master handles the response, do\r\nthis:\r\n\r\n    worker = asyncrun foo\r\n    worker.receive = (msg) ->\r\n        # handle the receive here\r\n\r\nIn the submodule, the setup is similiar. Note that in a submodule, we use the\r\nkeyword `moduleSelf` to refer to the current program:\r\n\r\n    foo = submodule\r\n        moduleSelf.receive = (msg) ->\r\n            # do some computations\r\n            someReply = ...\r\n            moduleSelf.reply someReply\r\n\r\n\r\n## Submodules Can Spawn Themselves and Other Submodules (Limited Support)\r\n\r\nSubmodules can spawn themselves:\r\n\r\n    foo = submodule\r\n        moduleSelf.receive = (msg) ->\r\n            # some work requires sub-workers\r\n            subworker = asyncrun moduleSelf\r\n            \r\nIt can also spawn other submodules:\r\n\r\n    foo = submodule\r\n        bar = submodule\r\n            # bar code here\r\n            \r\n        subworker = asyncrun bar\r\n        # setup and send messages\r\n\r\nThis corresponds to the HTML5 notion of *subworkers*. Unfortunately not every\r\nbrowser supports it. As of writing only Firefox supports subworkers. On the\r\nserver-side, node.js cluster forbids forking from worker processes, although\r\nit may be possible to modify the code.\r\n\r\n\r\n## Termination\r\n\r\nThe worker can close itself:\r\n\r\n    moduleSelf.close()\r\n\r\n(Note that in CoffeeScript you have to add the parentheses to call a method\r\nwith no arguments, otherwise you are just referring the method as an object.)\r\n\r\nSimilarly, the master can force-terminate the worker:\r\n\r\n    worker.terminate()\r\n\r\n\r\n## Error Handling\r\n\r\nIf a worker runs into an error, and the error propagates to the master, the\r\nmaster can specify a handler for such error:\r\n\r\n    worker = asyncrun foo\r\n    worker.error = (err) ->\r\n        # handle the err\r\n\r\nTo facilitate debugging, the handler currently only works for HTML5 worker\r\nerrors. When targeting node.js, exception raised in the worker is not caught\r\nby a top-level catch, therefore an uncaught exception will die in place.\r\n\r\n\r\n## Specifying the Worker Load Path for HTML5 Workers\r\n\r\nOne design flaw in the current HTML5 worker draft is that workers have to be\r\nloaded with a separate URL, and current browser implementations are messy. For\r\nexample, all supporting browsers (Chrome, Safari, Firefox) loads workers from\r\nthe relative path of the *HTML page*, not the *master program script*. While\r\nChrome supports relative path in the worker load URL, Firefox doesn't support\r\nit and you have to specify the full URL. This is a problem if your web site\r\nhas a layout like this:\r\n\r\n    /\r\n    /index.html\r\n    /js\r\n    /js/main.js\r\n    /js/worker.js\r\n\r\nTo circumvent the problem, DoubleShot has a global variable with which you can\r\nspecify the worker's load path (suppose the web site is example.com):\r\n\r\n    <!-- works in Chrome -->\r\n    <script>_submoduleLoadPath = \"js/\";</script>\r\n\r\n    <!-- works in Firefox -->\r\n    <script>_submoduleLoadPath = \"http://example.com/js/\";</script>\r\n\r\n    <script src=\"js/main.js\"></script>\r\n\r\nAdmittedly it's not an elegant solution. Better for the browser and standard\r\nmakers to fix the problem.\r\n\r\n\r\n## Notes\r\n\r\n*   It's called `submodule` and `asyncrun` because the the program declared\r\n    inside is not really a standalone module, and the terms `module` and\r\n    `spawn` are already extensively used by node.js. Also `asyncrun` just\r\n    means what the term says: it runs the submodule program asynchronously in\r\n    another process or thread (depending on the platform implementation).\r\n\r\n\r\n## Acknowledgments\r\n\r\nProfessor John Mitchell of Stanford University inspired me to investigate the\r\nways to add concurrency primitives to JavaScript, which led to the present\r\nform of this project.\r\n\r\n","name":"DoubleShot","google":"","tagline":"A CoffeeScript Dialect with Cross-Platform Concurrency Primitives","note":"Don't delete this file! It's used internally to help with page regeneration."}